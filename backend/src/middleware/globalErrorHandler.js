// [advice from AI] ÌîÑÎ°úÎçïÏÖò Î†àÎ≤® Í∏ÄÎ°úÎ≤å ÏóêÎü¨ Ìï∏Îì§Îü¨
// ÏóêÎü¨ Î∂ÑÎ•ò, Î°úÍπÖ, ÏïåÎ¶º, Î≥µÍµ¨ Ï†ÑÎûµ ÌÜµÌï©

const fs = require('fs').promises;
const path = require('path');
const { circuitBreakerManager } = require('../utils/CircuitBreaker');

// [advice from AI] ÏóêÎü¨ Î∂ÑÎ•ò Î∞è Ïã¨Í∞ÅÎèÑ Ï†ïÏùò
const ERROR_CATEGORIES = {
  CRITICAL: {
    level: 1,
    description: 'Ï¶âÏãú ÎåÄÏùë ÌïÑÏöîÌïú ÏãúÏä§ÌÖú Ïû•Ïï†',
    autoRecover: false,
    alertRequired: true,
    examples: ['Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®', 'Î©îÎ™®Î¶¨ Î∂ÄÏ°±', 'ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ Î∂ÄÏ°±']
  },
  HIGH: {
    level: 2,
    description: 'ÏÑúÎπÑÏä§ ÏòÅÌñ•ÎèÑÍ∞Ä ÎÜíÏùÄ Ïò§Î•ò',
    autoRecover: true,
    alertRequired: true,
    examples: ['Ïô∏Î∂Ä API Ïó∞Í≤∞ Ïã§Ìå®', 'Circuit Breaker OPEN', 'Ïù∏Ï¶ù ÏÑúÎπÑÏä§ Ïû•Ïï†']
  },
  MEDIUM: {
    level: 3,
    description: 'ÏùºÎ∂Ä Í∏∞Îä•Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÎäî Ïò§Î•ò',
    autoRecover: true,
    alertRequired: false,
    examples: ['ÌååÏùº ÏóÖÎ°úÎìú Ïã§Ìå®', 'Ï∫êÏãú Ïó∞Í≤∞ Ïã§Ìå®', 'Ïù¥Î©îÏùº Î∞úÏÜ° Ïã§Ìå®']
  },
  LOW: {
    level: 4,
    description: 'ÏÇ¨Ïö©Ïûê Í≤ΩÌóòÏóê ÎØ∏ÎØ∏Ìïú ÏòÅÌñ•',
    autoRecover: true,
    alertRequired: false,
    examples: ['Í≤ÄÏ¶ù Ïò§Î•ò', 'ÏöîÏ≤≠ ÌòïÏãù Ïò§Î•ò', 'Í∂åÌïú Î∂ÄÏ°±']
  },
  INFO: {
    level: 5,
    description: 'Ï†ïÎ≥¥ÏÑ± Î°úÍ∑∏',
    autoRecover: false,
    alertRequired: false,
    examples: ['ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏', 'Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå', 'ÏÑ§Ï†ï Î≥ÄÍ≤Ω']
  }
};

// [advice from AI] ÏóêÎü¨ Ìå®ÌÑ¥ Îß§Ïπ≠
const ERROR_PATTERNS = [
  {
    pattern: /database|connection|pool|sql|postgres/i,
    category: 'CRITICAL',
    component: 'DATABASE',
    autoActions: ['retry_connection', 'circuit_breaker']
  },
  {
    pattern: /memory|heap|out of memory/i,
    category: 'CRITICAL',
    component: 'SYSTEM',
    autoActions: ['gc_collect', 'restart_service']
  },
  {
    pattern: /disk|storage|ENOSPC/i,
    category: 'CRITICAL',
    component: 'SYSTEM',
    autoActions: ['cleanup_logs', 'alert_admin']
  },
  {
    pattern: /timeout|ETIMEDOUT|ECONNRESET/i,
    category: 'HIGH',
    component: 'NETWORK',
    autoActions: ['retry_request', 'circuit_breaker']
  },
  {
    pattern: /authentication|unauthorized|jwt|token/i,
    category: 'HIGH',
    component: 'AUTH',
    autoActions: ['refresh_token', 'redirect_login']
  },
  {
    pattern: /validation|invalid|bad request/i,
    category: 'LOW',
    component: 'VALIDATION',
    autoActions: ['log_only']
  },
  {
    pattern: /permission|forbidden|access denied/i,
    category: 'LOW',
    component: 'AUTHORIZATION',
    autoActions: ['log_only']
  }
];

class GlobalErrorHandler {
  constructor() {
    this.errorCounts = new Map();
    this.errorHistory = [];
    this.maxHistorySize = 1000;
    this.alertThresholds = {
      CRITICAL: 1,    // 1Ìöå Î∞úÏÉùÏãú Ï¶âÏãú ÏïåÎ¶º
      HIGH: 3,        // 3Ìöå Î∞úÏÉùÏãú ÏïåÎ¶º
      MEDIUM: 10,     // 10Ìöå Î∞úÏÉùÏãú ÏïåÎ¶º
      LOW: 50         // 50Ìöå Î∞úÏÉùÏãú ÏïåÎ¶º
    };
    
    // ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖò Îß§Ìïë
    this.autoActions = {
      retry_connection: this.retryDatabaseConnection.bind(this),
      circuit_breaker: this.handleCircuitBreaker.bind(this),
      gc_collect: this.forceGarbageCollection.bind(this),
      restart_service: this.restartService.bind(this),
      cleanup_logs: this.cleanupLogs.bind(this),
      alert_admin: this.sendAdminAlert.bind(this),
      retry_request: this.retryRequest.bind(this),
      refresh_token: this.refreshAuthToken.bind(this),
      redirect_login: this.redirectToLogin.bind(this),
      log_only: this.logOnly.bind(this)
    };
    
    // ÏóêÎü¨ Î°úÍ∑∏ ÌååÏùº Í≤ΩÎ°ú
    this.logPath = path.join(process.cwd(), 'logs');
    this.ensureLogDirectory();
  }

  // [advice from AI] Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  async ensureLogDirectory() {
    try {
      await fs.mkdir(this.logPath, { recursive: true });
    } catch (error) {
      console.error('Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± Ïã§Ìå®:', error);
    }
  }

  // [advice from AI] Î©îÏù∏ ÏóêÎü¨ Ï≤òÎ¶¨ Ìï®Ïàò
  async handleError(error, context = {}) {
    const errorInfo = this.analyzeError(error, context);
    
    // ÏóêÎü¨ ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï∂îÍ∞Ä
    this.addToHistory(errorInfo);
    
    // ÏóêÎü¨ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
    this.incrementErrorCount(errorInfo);
    
    // Î°úÍπÖ
    await this.logError(errorInfo);
    
    // ÏïåÎ¶º ÌôïÏù∏ Î∞è Î∞úÏÜ°
    await this.checkAndSendAlert(errorInfo);
    
    // ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìñâ
    await this.executeAutoActions(errorInfo);
    
    // Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
    this.updateMetrics(errorInfo);
    
    return errorInfo;
  }

  // [advice from AI] ÏóêÎü¨ Î∂ÑÏÑù Î∞è Î∂ÑÎ•ò
  analyzeError(error, context) {
    const timestamp = new Date().toISOString();
    const errorMessage = error.message || error.toString();
    const stackTrace = error.stack || '';
    
    // Ìå®ÌÑ¥ Îß§Ïπ≠ÏúºÎ°ú ÏóêÎü¨ Î∂ÑÎ•ò
    let category = 'MEDIUM';
    let component = 'UNKNOWN';
    let autoActions = ['log_only'];
    
    for (const pattern of ERROR_PATTERNS) {
      if (pattern.pattern.test(errorMessage) || pattern.pattern.test(stackTrace)) {
        category = pattern.category;
        component = pattern.component;
        autoActions = pattern.autoActions;
        break;
      }
    }
    
    // HTTP ÏÉÅÌÉú ÏΩîÎìú Í∏∞Î∞ò Î∂ÑÎ•ò
    if (error.status) {
      if (error.status >= 500) {
        category = 'HIGH';
      } else if (error.status >= 400) {
        category = 'LOW';
      }
    }
    
    // Circuit Breaker Í¥ÄÎ†® ÏóêÎü¨
    if (error.code === 'CIRCUIT_OPEN') {
      category = 'HIGH';
      component = 'CIRCUIT_BREAKER';
      autoActions = ['circuit_breaker'];
    }
    
    return {
      id: this.generateErrorId(),
      timestamp,
      category,
      component,
      level: ERROR_CATEGORIES[category].level,
      message: errorMessage,
      stack: stackTrace,
      code: error.code || 'UNKNOWN',
      status: error.status || null,
      context: {
        ...context,
        userId: context.userId || null,
        requestId: context.requestId || null,
        endpoint: context.endpoint || null,
        userAgent: context.userAgent || null,
        ip: context.ip || null
      },
      autoActions,
      recovered: false,
      alertSent: false
    };
  }

  // [advice from AI] Í≥†Ïú† ÏóêÎü¨ ID ÏÉùÏÑ±
  generateErrorId() {
    return `ERR_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // [advice from AI] ÏóêÎü¨ ÌûàÏä§ÌÜ†Î¶¨ Í¥ÄÎ¶¨
  addToHistory(errorInfo) {
    this.errorHistory.push(errorInfo);
    
    // ÌûàÏä§ÌÜ†Î¶¨ ÌÅ¨Í∏∞ Ï†úÌïú
    if (this.errorHistory.length > this.maxHistorySize) {
      this.errorHistory = this.errorHistory.slice(-this.maxHistorySize);
    }
  }

  // [advice from AI] ÏóêÎü¨ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
  incrementErrorCount(errorInfo) {
    const key = `${errorInfo.category}_${errorInfo.component}`;
    const current = this.errorCounts.get(key) || { count: 0, lastOccurrence: null };
    
    this.errorCounts.set(key, {
      count: current.count + 1,
      lastOccurrence: errorInfo.timestamp,
      category: errorInfo.category,
      component: errorInfo.component
    });
  }

  // [advice from AI] ÏóêÎü¨ Î°úÍπÖ
  async logError(errorInfo) {
    const logEntry = {
      ...errorInfo,
      hostname: require('os').hostname(),
      pid: process.pid,
      memory: process.memoryUsage(),
      uptime: process.uptime()
    };
    
    // ÏΩòÏÜî Î°úÍπÖ (Í∞úÎ∞ú ÌôòÍ≤Ω)
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[${errorInfo.category}] ${errorInfo.component}: ${errorInfo.message}`);
      if (errorInfo.level <= 2) {
        console.error(errorInfo.stack);
      }
    }
    
    // ÌååÏùº Î°úÍπÖ
    try {
      const logFile = path.join(this.logPath, `error_${new Date().toISOString().split('T')[0]}.log`);
      const logLine = JSON.stringify(logEntry) + '\n';
      
      await fs.appendFile(logFile, logLine);
    } catch (logError) {
      console.error('ÏóêÎü¨ Î°úÍ∑∏ ÌååÏùº Ïì∞Í∏∞ Ïã§Ìå®:', logError);
    }
  }

  // [advice from AI] ÏïåÎ¶º ÌôïÏù∏ Î∞è Î∞úÏÜ°
  async checkAndSendAlert(errorInfo) {
    const key = `${errorInfo.category}_${errorInfo.component}`;
    const errorCount = this.errorCounts.get(key);
    const threshold = this.alertThresholds[errorInfo.category];
    
    if (errorCount && errorCount.count >= threshold && !errorInfo.alertSent) {
      await this.sendAlert(errorInfo, errorCount.count);
      errorInfo.alertSent = true;
    }
  }

  // [advice from AI] ÏïåÎ¶º Î∞úÏÜ°
  async sendAlert(errorInfo, count) {
    const alertData = {
      severity: errorInfo.category,
      component: errorInfo.component,
      message: errorInfo.message,
      count,
      timestamp: errorInfo.timestamp,
      errorId: errorInfo.id
    };
    
    console.log(`üö® [ALERT] ${errorInfo.category} - ${errorInfo.component}: ${errorInfo.message} (${count}Ìöå Î∞úÏÉù)`);
    
    // Ïã§Ï†ú ÏïåÎ¶º ÏãúÏä§ÌÖú Ïó∞Îèô (Ïòà: Slack, Email, SMS)
    // await this.sendSlackAlert(alertData);
    // await this.sendEmailAlert(alertData);
  }

  // [advice from AI] ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìñâ
  async executeAutoActions(errorInfo) {
    for (const actionName of errorInfo.autoActions) {
      const action = this.autoActions[actionName];
      
      if (action) {
        try {
          console.log(`üîß ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìñâ: ${actionName}`);
          await action(errorInfo);
        } catch (actionError) {
          console.error(`ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìå® (${actionName}):`, actionError);
        }
      }
    }
  }

  // [advice from AI] ÏûêÎèô Î≥µÍµ¨ Ïï°ÏÖòÎì§
  async retryDatabaseConnection(errorInfo) {
    console.log('üîÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ');
    // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïû¨Ïó∞Í≤∞ Î°úÏßÅ
  }

  async handleCircuitBreaker(errorInfo) {
    console.log('üîå Circuit Breaker ÏÉÅÌÉú ÌôïÏù∏');
    const states = circuitBreakerManager.getAllStates();
    
    // OPEN ÏÉÅÌÉúÏù∏ Circuit BreakerÍ∞Ä ÏûàÏúºÎ©¥ Î°úÍ∑∏
    Object.entries(states.breakers).forEach(([name, state]) => {
      if (state.state === 'OPEN') {
        console.log(`‚ö†Ô∏è Circuit Breaker '${name}' OPEN ÏÉÅÌÉú`);
      }
    });
  }

  async forceGarbageCollection(errorInfo) {
    if (global.gc) {
      console.log('üóëÔ∏è Í∞ïÏ†ú Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò Ïã§Ìñâ');
      global.gc();
    }
  }

  async restartService(errorInfo) {
    console.log('üîÑ ÏÑúÎπÑÏä§ Ïû¨ÏãúÏûë Ïã†Ìò∏ Î∞úÏÜ°');
    // Ïã§Ï†ú ÏÑúÎπÑÏä§ Ïû¨ÏãúÏûëÏùÄ ÌîÑÎ°úÏÑ∏Ïä§ Îß§ÎãàÏ†Ä(PM2, Docker)Ïóê ÏúÑÏûÑ
    process.emit('SIGTERM');
  }

  async cleanupLogs(errorInfo) {
    console.log('üßπ Ïò§ÎûòÎêú Î°úÍ∑∏ ÌååÏùº Ï†ïÎ¶¨');
    try {
      const files = await fs.readdir(this.logPath);
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - 7); // 7Ïùº Ïù¥Ï†Ñ
      
      for (const file of files) {
        const filePath = path.join(this.logPath, file);
        const stats = await fs.stat(filePath);
        
        if (stats.mtime < cutoffDate) {
          await fs.unlink(filePath);
          console.log(`üóëÔ∏è Ïò§ÎûòÎêú Î°úÍ∑∏ ÌååÏùº ÏÇ≠Ï†ú: ${file}`);
        }
      }
    } catch (cleanupError) {
      console.error('Î°úÍ∑∏ Ï†ïÎ¶¨ Ïã§Ìå®:', cleanupError);
    }
  }

  async sendAdminAlert(errorInfo) {
    console.log('üìß Í¥ÄÎ¶¨Ïûê ÏïåÎ¶º Î∞úÏÜ°');
    // Ïã§Ï†ú Í¥ÄÎ¶¨Ïûê ÏïåÎ¶º Î°úÏßÅ
  }

  async retryRequest(errorInfo) {
    console.log('üîÑ ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ Î°úÏßÅ');
    // Ïã§Ï†ú ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ Î°úÏßÅ
  }

  async refreshAuthToken(errorInfo) {
    console.log('üîë Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Í∞±Ïã†');
    // Ïã§Ï†ú ÌÜ†ÌÅ∞ Í∞±Ïã† Î°úÏßÅ
  }

  async redirectToLogin(errorInfo) {
    console.log('üîê Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄ Î¶¨Îã§Ïù¥Î†âÌä∏');
    // Ïã§Ï†ú Î¶¨Îã§Ïù¥Î†âÌä∏ Î°úÏßÅ
  }

  async logOnly(errorInfo) {
    // Î°úÍπÖÎßå ÏàòÌñâ (Ïù¥ÎØ∏ ÏôÑÎ£åÎê®)
  }

  // [advice from AI] Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
  updateMetrics(errorInfo) {
    // Prometheus Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏ Îì±
  }

  // [advice from AI] Express ÏóêÎü¨ ÎØ∏Îì§Ïõ®Ïñ¥
  expressErrorHandler() {
    return async (error, req, res, next) => {
      const context = {
        endpoint: `${req.method} ${req.originalUrl}`,
        userId: req.user?.id,
        userAgent: req.get('User-Agent'),
        ip: req.ip || req.connection.remoteAddress,
        requestId: req.id || req.headers['x-request-id']
      };
      
      const errorInfo = await this.handleError(error, context);
      
      // HTTP ÏùëÎãµ
      const statusCode = error.status || 500;
      const response = {
        success: false,
        error: errorInfo.category === 'LOW' ? error.message : 'Internal Server Error',
        errorId: errorInfo.id,
        timestamp: errorInfo.timestamp
      };
      
      // Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî Îçî ÏûêÏÑ∏Ìïú Ï†ïÎ≥¥ Ï†úÍ≥µ
      if (process.env.NODE_ENV !== 'production') {
        response.stack = error.stack;
        response.details = errorInfo;
      }
      
      res.status(statusCode).json(response);
    };
  }

  // [advice from AI] Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏòàÏô∏ Ìï∏Îì§Îü¨
  setupGlobalHandlers() {
    process.on('uncaughtException', async (error) => {
      console.error('üö® Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏòàÏô∏:', error);
      await this.handleError(error, { source: 'uncaughtException' });
      
      // Ïã¨Í∞ÅÌïú Ïò§Î•òÏù¥ÎØÄÎ°ú ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å
      process.exit(1);
    });
    
    process.on('unhandledRejection', async (reason, promise) => {
      console.error('üö® Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise Í±∞Î∂Ä:', reason);
      await this.handleError(reason, { source: 'unhandledRejection', promise });
    });
  }

  // [advice from AI] ÏóêÎü¨ ÌÜµÍ≥Ñ Ï°∞Ìöå
  getErrorStats() {
    const stats = {
      totalErrors: this.errorHistory.length,
      errorsByCategory: {},
      errorsByComponent: {},
      recentErrors: this.errorHistory.slice(-10),
      topErrors: []
    };
    
    // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌÜµÍ≥Ñ
    for (const [key, data] of this.errorCounts) {
      if (!stats.errorsByCategory[data.category]) {
        stats.errorsByCategory[data.category] = 0;
      }
      stats.errorsByCategory[data.category] += data.count;
      
      if (!stats.errorsByComponent[data.component]) {
        stats.errorsByComponent[data.component] = 0;
      }
      stats.errorsByComponent[data.component] += data.count;
    }
    
    // ÏÉÅÏúÑ ÏóêÎü¨Îì§
    stats.topErrors = Array.from(this.errorCounts.entries())
      .sort((a, b) => b[1].count - a[1].count)
      .slice(0, 10)
      .map(([key, data]) => ({
        key,
        category: data.category,
        component: data.component,
        count: data.count,
        lastOccurrence: data.lastOccurrence
      }));
    
    return stats;
  }

  // [advice from AI] ÏóêÎü¨ ÌûàÏä§ÌÜ†Î¶¨ Ï¥àÍ∏∞Ìôî
  clearHistory() {
    this.errorHistory = [];
    this.errorCounts.clear();
    console.log('üìä ÏóêÎü¨ ÌûàÏä§ÌÜ†Î¶¨ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
  }
}

// [advice from AI] Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
const globalErrorHandler = new GlobalErrorHandler();

module.exports = {
  GlobalErrorHandler,
  globalErrorHandler,
  ERROR_CATEGORIES,
  ERROR_PATTERNS
};
