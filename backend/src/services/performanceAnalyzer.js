// [advice from AI] ÌîÑÎ°úÎçïÏÖò Î†àÎ≤® ÏÑ±Îä• Î∂ÑÏÑù Î∞è ÏòàÏ∏° ÏãúÏä§ÌÖú
// Ìä∏Î†åÎìú Î∂ÑÏÑù, Ïö©Îüâ Í≥ÑÌöç, ÏÑ±Îä• Î≥ëÎ™© Í∞êÏßÄ

class PerformanceAnalyzer {
  constructor(options = {}) {
    this.name = options.name || 'PerformanceAnalyzer';
    this.analysisWindow = options.analysisWindow || 24 * 60 * 60 * 1000; // 24ÏãúÍ∞Ñ
    this.predictionHorizon = options.predictionHorizon || 7 * 24 * 60 * 60 * 1000; // 7Ïùº
    this.trendSensitivity = options.trendSensitivity || 0.1;
    this.anomalyThreshold = options.anomalyThreshold || 2.5; // ÌëúÏ§ÄÌé∏Ï∞® Î∞∞Ïàò
    
    // Î∂ÑÏÑù Í≤∞Í≥º Ï∫êÏãú
    this.analysisCache = new Map();
    this.trendCache = new Map();
    this.predictionCache = new Map();
    
    // ÏÑ±Îä• ÏßÄÌëú Ï†ïÏùò
    this.performanceIndicators = {
      cpu: {
        metrics: ['cpu_usage', 'cpu_load_1m', 'cpu_load_5m', 'cpu_load_15m'],
        thresholds: { warning: 70, critical: 85, emergency: 95 },
        unit: 'percent'
      },
      memory: {
        metrics: ['memory_usage', 'app_memory_heap'],
        thresholds: { warning: 75, critical: 90, emergency: 95 },
        unit: 'percent'
      },
      disk: {
        metrics: ['disk_usage'],
        thresholds: { warning: 80, critical: 90, emergency: 95 },
        unit: 'percent'
      },
      database: {
        metrics: ['db_active_connections', 'db_avg_query_time'],
        thresholds: { warning: 50, critical: 80, emergency: 95 },
        unit: 'count'
      },
      network: {
        metrics: ['network_throughput', 'network_latency'],
        thresholds: { warning: 100, critical: 500, emergency: 1000 },
        unit: 'ms'
      }
    };
    
    console.log(`üìà ÏÑ±Îä• Î∂ÑÏÑùÍ∏∞ '${this.name}' Ï¥àÍ∏∞Ìôî ÏôÑÎ£å`);
  }

  // [advice from AI] Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
  async analyzeMetrics(metricsData, timeRange = this.analysisWindow) {
    const analysisId = `analysis_${Date.now()}`;
    const startTime = Date.now();
    
    try {
      console.log(`üîç ÏÑ±Îä• Î∂ÑÏÑù ÏãúÏûë: ${analysisId}`);
      
      const analysis = {
        id: analysisId,
        timestamp: startTime,
        timeRange,
        metrics: {},
        trends: {},
        anomalies: [],
        predictions: {},
        recommendations: [],
        summary: {}
      };
      
      // Í∞Å ÏÑ±Îä• ÏßÄÌëúÎ≥Ñ Î∂ÑÏÑù
      for (const [category, config] of Object.entries(this.performanceIndicators)) {
        const categoryMetrics = this.extractCategoryMetrics(metricsData, config.metrics);
        
        if (categoryMetrics.length > 0) {
          analysis.metrics[category] = await this.analyzeCategoryMetrics(
            category, 
            categoryMetrics, 
            config
          );
        }
      }
      
      // Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú Ìä∏Î†åÎìú Î∂ÑÏÑù
      analysis.trends = await this.analyzeTrends(metricsData, timeRange);
      
      // Ïù¥ÏÉÅ ÏßïÌõÑ Í∞êÏßÄ
      analysis.anomalies = await this.detectAnomalies(metricsData);
      
      // ÏÑ±Îä• ÏòàÏ∏°
      analysis.predictions = await this.generatePredictions(metricsData);
      
      // Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
      analysis.recommendations = this.generateRecommendations(analysis);
      
      // Î∂ÑÏÑù ÏöîÏïΩ
      analysis.summary = this.generateSummary(analysis);
      
      // Î∂ÑÏÑù ÏôÑÎ£å ÏãúÍ∞Ñ
      analysis.duration = Date.now() - startTime;
      
      // Ï∫êÏãúÏóê Ï†ÄÏû•
      this.analysisCache.set(analysisId, analysis);
      
      console.log(`‚úÖ ÏÑ±Îä• Î∂ÑÏÑù ÏôÑÎ£å: ${analysisId} (${analysis.duration}ms)`);
      
      return analysis;
      
    } catch (error) {
      console.error(`‚ùå ÏÑ±Îä• Î∂ÑÏÑù Ïã§Ìå®: ${analysisId}`, error);
      throw error;
    }
  }

  // [advice from AI] Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î©îÌä∏Î¶≠ Ï∂îÏ∂ú
  extractCategoryMetrics(metricsData, metricNames) {
    const categoryMetrics = [];
    
    metricsData.forEach(metric => {
      if (metric.data) {
        metricNames.forEach(metricName => {
          const value = this.extractNestedValue(metric.data, metricName);
          if (value !== null && value !== undefined) {
            categoryMetrics.push({
              name: metricName,
              value: parseFloat(value),
              timestamp: metric.timestamp,
              collector: metric.collector
            });
          }
        });
      }
    });
    
    return categoryMetrics.sort((a, b) => a.timestamp - b.timestamp);
  }

  // [advice from AI] Ï§ëÏ≤©Îêú Í∞ùÏ≤¥ÏóêÏÑú Í∞í Ï∂îÏ∂ú
  extractNestedValue(obj, path) {
    // cpu_usage -> obj.cpu.usage
    // memory_usage -> obj.memory.usage
    // db_active_connections -> obj.connections.active
    
    const pathMappings = {
      'cpu_usage': 'cpu.usage',
      'memory_usage': 'memory.usage',
      'disk_usage': 'disk.usage',
      'db_active_connections': 'connections.active',
      'db_avg_query_time': 'queries.avgTime',
      'app_memory_heap': 'process.memory.heapUsed'
    };
    
    const actualPath = pathMappings[path] || path;
    const keys = actualPath.split('.');
    let value = obj;
    
    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key];
      } else {
        return null;
      }
    }
    
    return value;
  }

  // [advice from AI] Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î©îÌä∏Î¶≠ Î∂ÑÏÑù
  async analyzeCategoryMetrics(category, metrics, config) {
    if (metrics.length === 0) {
      return null;
    }
    
    const values = metrics.map(m => m.value);
    const timestamps = metrics.map(m => m.timestamp);
    
    // Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    const stats = this.calculateBasicStats(values);
    
    // ÏãúÍ≥ÑÏó¥ Î∂ÑÏÑù
    const timeSeriesAnalysis = this.analyzeTimeSeries(values, timestamps);
    
    // ÏûÑÍ≥ÑÍ∞í Î∂ÑÏÑù
    const thresholdAnalysis = this.analyzeThresholds(values, config.thresholds);
    
    // ÏÑ±Îä• Îì±Í∏â Í≥ÑÏÇ∞
    const performanceGrade = this.calculatePerformanceGrade(stats, config.thresholds);
    
    return {
      category,
      stats,
      timeSeries: timeSeriesAnalysis,
      thresholds: thresholdAnalysis,
      grade: performanceGrade,
      dataPoints: metrics.length,
      timeRange: {
        start: Math.min(...timestamps),
        end: Math.max(...timestamps)
      }
    };
  }

  // [advice from AI] Í∏∞Î≥∏ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
  calculateBasicStats(values) {
    if (values.length === 0) return null;
    
    const sorted = [...values].sort((a, b) => a - b);
    const sum = values.reduce((acc, val) => acc + val, 0);
    const mean = sum / values.length;
    const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    
    return {
      count: values.length,
      sum: Math.round(sum * 100) / 100,
      mean: Math.round(mean * 100) / 100,
      median: sorted[Math.floor(sorted.length / 2)],
      min: Math.min(...values),
      max: Math.max(...values),
      stdDev: Math.round(stdDev * 100) / 100,
      variance: Math.round(variance * 100) / 100,
      percentiles: {
        p25: sorted[Math.floor(sorted.length * 0.25)],
        p75: sorted[Math.floor(sorted.length * 0.75)],
        p90: sorted[Math.floor(sorted.length * 0.90)],
        p95: sorted[Math.floor(sorted.length * 0.95)],
        p99: sorted[Math.floor(sorted.length * 0.99)]
      }
    };
  }

  // [advice from AI] ÏãúÍ≥ÑÏó¥ Î∂ÑÏÑù
  analyzeTimeSeries(values, timestamps) {
    if (values.length < 2) return null;
    
    // Ìä∏Î†åÎìú Í≥ÑÏÇ∞ (ÏÑ†Ìòï ÌöåÍ∑Ä)
    const trend = this.calculateLinearTrend(values, timestamps);
    
    // Î≥ÄÎèôÏÑ± Î∂ÑÏÑù
    const volatility = this.calculateVolatility(values);
    
    // Ï£ºÍ∏∞ÏÑ± Í∞êÏßÄ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
    const seasonality = this.detectSeasonality(values, timestamps);
    
    return {
      trend,
      volatility,
      seasonality,
      dataPoints: values.length,
      timeSpan: timestamps[timestamps.length - 1] - timestamps[0]
    };
  }

  // [advice from AI] ÏÑ†Ìòï Ìä∏Î†åÎìú Í≥ÑÏÇ∞
  calculateLinearTrend(values, timestamps) {
    const n = values.length;
    if (n < 2) return null;
    
    // ÏãúÍ∞ÑÏùÑ Ï†ïÍ∑úÌôî (0Î∂ÄÌÑ∞ ÏãúÏûë)
    const minTime = Math.min(...timestamps);
    const normalizedTimes = timestamps.map(t => t - minTime);
    
    // ÏÑ†Ìòï ÌöåÍ∑Ä Í≥ÑÏÇ∞
    const sumX = normalizedTimes.reduce((sum, x) => sum + x, 0);
    const sumY = values.reduce((sum, y) => sum + y, 0);
    const sumXY = normalizedTimes.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = normalizedTimes.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    // Í≤∞Ï†ïÍ≥ÑÏàò (R¬≤) Í≥ÑÏÇ∞
    const meanY = sumY / n;
    const ssRes = values.reduce((sum, y, i) => {
      const predicted = slope * normalizedTimes[i] + intercept;
      return sum + Math.pow(y - predicted, 2);
    }, 0);
    const ssTot = values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
    const rSquared = 1 - (ssRes / ssTot);
    
    // Ìä∏Î†åÎìú Î∞©Ìñ• Î∂ÑÎ•ò
    let direction = 'stable';
    if (Math.abs(slope) > this.trendSensitivity) {
      direction = slope > 0 ? 'increasing' : 'decreasing';
    }
    
    return {
      slope: Math.round(slope * 10000) / 10000,
      intercept: Math.round(intercept * 100) / 100,
      rSquared: Math.round(rSquared * 100) / 100,
      direction,
      confidence: rSquared > 0.7 ? 'high' : rSquared > 0.4 ? 'medium' : 'low'
    };
  }

  // [advice from AI] Î≥ÄÎèôÏÑ± Í≥ÑÏÇ∞
  calculateVolatility(values) {
    if (values.length < 2) return 0;
    
    const changes = [];
    for (let i = 1; i < values.length; i++) {
      const change = (values[i] - values[i-1]) / values[i-1];
      changes.push(change);
    }
    
    const mean = changes.reduce((sum, change) => sum + change, 0) / changes.length;
    const variance = changes.reduce((sum, change) => sum + Math.pow(change - mean, 2), 0) / changes.length;
    
    return Math.round(Math.sqrt(variance) * 10000) / 10000;
  }

  // [advice from AI] Ï£ºÍ∏∞ÏÑ± Í∞êÏßÄ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
  detectSeasonality(values, timestamps) {
    if (values.length < 24) return null; // ÏµúÏÜå 24Í∞ú Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ ÌïÑÏöî
    
    // ÏãúÍ∞Ñ Í∞ÑÍ≤© Í≥ÑÏÇ∞
    const intervals = [];
    for (let i = 1; i < timestamps.length; i++) {
      intervals.push(timestamps[i] - timestamps[i-1]);
    }
    
    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
    
    // Í∞ÑÎã®Ìïú Ï£ºÍ∏∞ÏÑ± Í≤ÄÏÇ¨ (1ÏãúÍ∞Ñ, 1Ïùº Ï£ºÍ∏∞)
    const hourlyPattern = this.checkPattern(values, Math.round(3600000 / avgInterval)); // 1ÏãúÍ∞Ñ
    const dailyPattern = this.checkPattern(values, Math.round(86400000 / avgInterval)); // 1Ïùº
    
    return {
      detected: hourlyPattern.strength > 0.3 || dailyPattern.strength > 0.3,
      patterns: {
        hourly: hourlyPattern,
        daily: dailyPattern
      }
    };
  }

  // [advice from AI] Ìå®ÌÑ¥ Í∞ïÎèÑ Í≤ÄÏÇ¨
  checkPattern(values, period) {
    if (values.length < period * 2) {
      return { strength: 0, confidence: 'low' };
    }
    
    let correlation = 0;
    let validPairs = 0;
    
    for (let i = 0; i < values.length - period; i++) {
      if (i + period < values.length) {
        correlation += values[i] * values[i + period];
        validPairs++;
      }
    }
    
    const strength = validPairs > 0 ? Math.abs(correlation / validPairs) / Math.max(...values) : 0;
    
    return {
      strength: Math.round(strength * 100) / 100,
      confidence: strength > 0.5 ? 'high' : strength > 0.3 ? 'medium' : 'low',
      period
    };
  }

  // [advice from AI] ÏûÑÍ≥ÑÍ∞í Î∂ÑÏÑù
  analyzeThresholds(values, thresholds) {
    const analysis = {
      warning: { count: 0, percentage: 0, latest: null },
      critical: { count: 0, percentage: 0, latest: null },
      emergency: { count: 0, percentage: 0, latest: null }
    };
    
    values.forEach((value, index) => {
      if (value >= thresholds.emergency) {
        analysis.emergency.count++;
        analysis.emergency.latest = index;
      } else if (value >= thresholds.critical) {
        analysis.critical.count++;
        analysis.critical.latest = index;
      } else if (value >= thresholds.warning) {
        analysis.warning.count++;
        analysis.warning.latest = index;
      }
    });
    
    const total = values.length;
    analysis.warning.percentage = Math.round((analysis.warning.count / total) * 100 * 100) / 100;
    analysis.critical.percentage = Math.round((analysis.critical.count / total) * 100 * 100) / 100;
    analysis.emergency.percentage = Math.round((analysis.emergency.count / total) * 100 * 100) / 100;
    
    return analysis;
  }

  // [advice from AI] ÏÑ±Îä• Îì±Í∏â Í≥ÑÏÇ∞
  calculatePerformanceGrade(stats, thresholds) {
    if (!stats) return 'Unknown';
    
    const avgValue = stats.mean;
    
    if (avgValue >= thresholds.emergency) return 'F'; // Îß§Ïö∞ ÎÇòÏÅ®
    if (avgValue >= thresholds.critical) return 'D';  // ÎÇòÏÅ®
    if (avgValue >= thresholds.warning) return 'C';   // Î≥¥ÌÜµ
    if (avgValue >= thresholds.warning * 0.7) return 'B'; // Ï¢ãÏùå
    return 'A'; // Îß§Ïö∞ Ï¢ãÏùå
  }

  // [advice from AI] Ìä∏Î†åÎìú Î∂ÑÏÑù
  async analyzeTrends(metricsData, timeRange) {
    const trends = {};
    
    for (const [category, config] of Object.entries(this.performanceIndicators)) {
      const categoryMetrics = this.extractCategoryMetrics(metricsData, config.metrics);
      
      if (categoryMetrics.length > 10) { // ÏµúÏÜå 10Í∞ú Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ ÌïÑÏöî
        const values = categoryMetrics.map(m => m.value);
        const timestamps = categoryMetrics.map(m => m.timestamp);
        
        trends[category] = this.calculateLinearTrend(values, timestamps);
      }
    }
    
    return trends;
  }

  // [advice from AI] Ïù¥ÏÉÅ ÏßïÌõÑ Í∞êÏßÄ
  async detectAnomalies(metricsData) {
    const anomalies = [];
    
    // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ïù¥ÏÉÅ ÏßïÌõÑ Í∞êÏßÄ
    for (const [category, config] of Object.entries(this.performanceIndicators)) {
      const categoryMetrics = this.extractCategoryMetrics(metricsData, config.metrics);
      
      if (categoryMetrics.length > 10) {
        const categoryAnomalies = this.detectCategoryAnomalies(category, categoryMetrics);
        anomalies.push(...categoryAnomalies);
      }
    }
    
    return anomalies.sort((a, b) => b.severity - a.severity);
  }

  // [advice from AI] Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ïù¥ÏÉÅ ÏßïÌõÑ Í∞êÏßÄ
  detectCategoryAnomalies(category, metrics) {
    const anomalies = [];
    const values = metrics.map(m => m.value);
    const stats = this.calculateBasicStats(values);
    
    if (!stats) return anomalies;
    
    const threshold = stats.mean + (this.anomalyThreshold * stats.stdDev);
    
    metrics.forEach((metric, index) => {
      if (metric.value > threshold) {
        const severity = this.calculateAnomalySeverity(metric.value, stats, threshold);
        
        anomalies.push({
          category,
          metricName: metric.name,
          value: metric.value,
          expectedRange: {
            min: stats.mean - stats.stdDev,
            max: stats.mean + stats.stdDev
          },
          threshold,
          severity,
          timestamp: metric.timestamp,
          deviation: Math.round(((metric.value - stats.mean) / stats.stdDev) * 100) / 100
        });
      }
    });
    
    return anomalies;
  }

  // [advice from AI] Ïù¥ÏÉÅ ÏßïÌõÑ Ïã¨Í∞ÅÎèÑ Í≥ÑÏÇ∞
  calculateAnomalySeverity(value, stats, threshold) {
    const deviations = (value - stats.mean) / stats.stdDev;
    
    if (deviations > 4) return 5; // Îß§Ïö∞ Ïã¨Í∞Å
    if (deviations > 3) return 4; // Ïã¨Í∞Å
    if (deviations > 2.5) return 3; // Î≥¥ÌÜµ
    if (deviations > 2) return 2; // Í≤ΩÎØ∏
    return 1; // ÎÇÆÏùå
  }

  // [advice from AI] ÏÑ±Îä• ÏòàÏ∏° ÏÉùÏÑ±
  async generatePredictions(metricsData) {
    const predictions = {};
    
    for (const [category, config] of Object.entries(this.performanceIndicators)) {
      const categoryMetrics = this.extractCategoryMetrics(metricsData, config.metrics);
      
      if (categoryMetrics.length > 20) { // ÏòàÏ∏°ÏùÑ ÏúÑÌïú Ï∂©Î∂ÑÌïú Îç∞Ïù¥ÌÑ∞
        predictions[category] = this.predictCategoryPerformance(category, categoryMetrics, config);
      }
    }
    
    return predictions;
  }

  // [advice from AI] Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏÑ±Îä• ÏòàÏ∏°
  predictCategoryPerformance(category, metrics, config) {
    const values = metrics.map(m => m.value);
    const timestamps = metrics.map(m => m.timestamp);
    
    // ÏÑ†Ìòï Ìä∏Î†åÎìú Í∏∞Î∞ò ÏòàÏ∏°
    const trend = this.calculateLinearTrend(values, timestamps);
    
    if (!trend || trend.confidence === 'low') {
      return {
        method: 'insufficient_data',
        confidence: 'low',
        message: 'ÏòàÏ∏°ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§'
      };
    }
    
    const lastTimestamp = timestamps[timestamps.length - 1];
    const lastValue = values[values.length - 1];
    
    // 7Ïùº ÌõÑ ÏòàÏ∏°Í∞í Í≥ÑÏÇ∞
    const futureTimestamp = lastTimestamp + this.predictionHorizon;
    const timeElapsed = futureTimestamp - lastTimestamp;
    const predictedValue = lastValue + (trend.slope * timeElapsed);
    
    // ÏûÑÍ≥ÑÍ∞í ÎèÑÎã¨ ÏãúÍ∞Ñ ÏòàÏ∏°
    const timeToWarning = this.calculateTimeToThreshold(
      lastValue, trend.slope, config.thresholds.warning
    );
    const timeToCritical = this.calculateTimeToThreshold(
      lastValue, trend.slope, config.thresholds.critical
    );
    
    return {
      method: 'linear_trend',
      confidence: trend.confidence,
      currentValue: Math.round(lastValue * 100) / 100,
      predictedValue: Math.round(predictedValue * 100) / 100,
      trend: trend.direction,
      timeHorizon: this.predictionHorizon,
      thresholdAlerts: {
        warning: timeToWarning ? {
          timeToReach: timeToWarning,
          expectedDate: new Date(lastTimestamp + timeToWarning).toISOString()
        } : null,
        critical: timeToCritical ? {
          timeToReach: timeToCritical,
          expectedDate: new Date(lastTimestamp + timeToCritical).toISOString()
        } : null
      }
    };
  }

  // [advice from AI] ÏûÑÍ≥ÑÍ∞í ÎèÑÎã¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
  calculateTimeToThreshold(currentValue, slope, threshold) {
    if (slope <= 0 || currentValue >= threshold) {
      return null; // Ï¶ùÍ∞Ä Ï∂îÏÑ∏Í∞Ä ÏïÑÎãàÍ±∞ÎÇò Ïù¥ÎØ∏ ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º
    }
    
    const timeToThreshold = (threshold - currentValue) / slope;
    
    // 1ÎÖÑ Ïù¥ÎÇ¥Ïùò ÏòàÏ∏°Îßå Ïú†Ìö®ÌïòÎã§Í≥† Í∞ÑÏ£º
    const maxPredictionTime = 365 * 24 * 60 * 60 * 1000; // 1ÎÖÑ
    
    return timeToThreshold <= maxPredictionTime ? timeToThreshold : null;
  }

  // [advice from AI] Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
  generateRecommendations(analysis) {
    const recommendations = [];
    
    // ÏÑ±Îä• Îì±Í∏â Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
    for (const [category, categoryAnalysis] of Object.entries(analysis.metrics)) {
      if (!categoryAnalysis) continue;
      
      const grade = categoryAnalysis.grade;
      const trend = analysis.trends[category];
      
      if (grade === 'F' || grade === 'D') {
        recommendations.push({
          category,
          priority: 'high',
          type: 'performance',
          title: `${category} ÏÑ±Îä• Í∞úÏÑ† ÌïÑÏöî`,
          description: `${category} ÏÑ±Îä•Ïù¥ ${grade} Îì±Í∏âÏúºÎ°ú Ï¶âÏãú Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.`,
          actions: this.getPerformanceActions(category, grade)
        });
      }
      
      if (trend && trend.direction === 'increasing' && trend.confidence !== 'low') {
        recommendations.push({
          category,
          priority: 'medium',
          type: 'trend',
          title: `${category} Ï¶ùÍ∞Ä Ï∂îÏÑ∏ Í∞êÏßÄ`,
          description: `${category} Î©îÌä∏Î¶≠Ïù¥ ÏßÄÏÜçÏ†ÅÏúºÎ°ú Ï¶ùÍ∞ÄÌïòÍ≥† ÏûàÏäµÎãàÎã§.`,
          actions: this.getTrendActions(category, trend)
        });
      }
    }
    
    // Ïù¥ÏÉÅ ÏßïÌõÑ Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
    analysis.anomalies.forEach(anomaly => {
      if (anomaly.severity >= 3) {
        recommendations.push({
          category: anomaly.category,
          priority: anomaly.severity >= 4 ? 'high' : 'medium',
          type: 'anomaly',
          title: `${anomaly.category} Ïù¥ÏÉÅ ÏßïÌõÑ Í∞êÏßÄ`,
          description: `${anomaly.metricName}ÏóêÏÑú ÎπÑÏ†ïÏÉÅÏ†ÅÏù∏ Í∞íÏù¥ Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.`,
          actions: this.getAnomalyActions(anomaly)
        });
      }
    });
    
    // ÏòàÏ∏° Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
    for (const [category, prediction] of Object.entries(analysis.predictions)) {
      if (prediction.thresholdAlerts) {
        if (prediction.thresholdAlerts.critical) {
          recommendations.push({
            category,
            priority: 'high',
            type: 'prediction',
            title: `${category} ÏûÑÍ≥ÑÍ∞í ÎèÑÎã¨ ÏòàÏÉÅ`,
            description: `ÌòÑÏû¨ Ï∂îÏÑ∏Î°úÎäî ${new Date(prediction.thresholdAlerts.critical.expectedDate).toLocaleDateString()}Ïóê ÏûÑÍ≥ÑÍ∞íÏóê ÎèÑÎã¨Ìï† ÏòàÏ†ïÏûÖÎãàÎã§.`,
            actions: this.getPredictionActions(category, prediction)
          });
        }
      }
    }
    
    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  // [advice from AI] ÏÑ±Îä• Í∞úÏÑ† Ïï°ÏÖò
  getPerformanceActions(category, grade) {
    const actions = {
      cpu: [
        'ÌîÑÎ°úÏÑ∏Ïä§ ÏµúÏ†ÅÌôî Î∞è Î∂àÌïÑÏöîÌïú ÏÑúÎπÑÏä§ Ï§ëÎã®',
        'CPU ÏßëÏïΩÏ†Å ÏûëÏóÖÏùò Ïä§ÏºÄÏ§ÑÎßÅ Ï°∞Ï†ï',
        'ÏÑúÎ≤Ñ Î¶¨ÏÜåÏä§ ÏóÖÍ∑∏Î†àÏù¥Îìú Í≤ÄÌÜ†'
      ],
      memory: [
        'Î©îÎ™®Î¶¨ ÎàÑÏàò Í≤ÄÏÇ¨ Î∞è ÏàòÏ†ï',
        'Ï∫êÏãú ÌÅ¨Í∏∞ Ï°∞Ï†ï',
        'Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏùÄ ÌîÑÎ°úÏÑ∏Ïä§ ÏµúÏ†ÅÌôî'
      ],
      disk: [
        'Î∂àÌïÑÏöîÌïú ÌååÏùº Ï†ïÎ¶¨',
        'Î°úÍ∑∏ Î°úÌÖåÏù¥ÏÖò ÏÑ§Ï†ï ÌôïÏù∏',
        'ÎîîÏä§ÌÅ¨ Í≥µÍ∞Ñ ÌôïÏû•'
      ],
      database: [
        'ÏøºÎ¶¨ ÏÑ±Îä• ÏµúÏ†ÅÌôî',
        'Ïù∏Îç±Ïä§ Ï∂îÍ∞Ä Î∞è ÏµúÏ†ÅÌôî',
        'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄ Ï°∞Ï†ï'
      ]
    };
    
    return actions[category] || ['ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Í∞ïÌôî', 'Î¶¨ÏÜåÏä§ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù'];
  }

  // [advice from AI] Ìä∏Î†åÎìú ÎåÄÏùë Ïï°ÏÖò
  getTrendActions(category, trend) {
    return [
      'Î¶¨ÏÜåÏä§ ÏÇ¨Ïö©Îüâ Ï¶ùÍ∞Ä ÏõêÏù∏ Î∂ÑÏÑù',
      'Ïö©Îüâ Í≥ÑÌöç ÏàòÎ¶Ω',
      'ÏïåÎ¶º ÏûÑÍ≥ÑÍ∞í Ï°∞Ï†ï Í≤ÄÌÜ†',
      'ÏûêÎèô Ïä§ÏºÄÏùºÎßÅ ÏÑ§Ï†ï ÌôïÏù∏'
    ];
  }

  // [advice from AI] Ïù¥ÏÉÅ ÏßïÌõÑ ÎåÄÏùë Ïï°ÏÖò
  getAnomalyActions(anomaly) {
    return [
      'Ïù¥ÏÉÅ ÏßïÌõÑ Î∞úÏÉù ÏãúÏ†ê ÏÉÅÏÑ∏ Î∂ÑÏÑù',
      'Í¥ÄÎ†® ÏãúÏä§ÌÖú Î°úÍ∑∏ ÌôïÏù∏',
      'Ïô∏Î∂Ä ÏöîÏù∏ ÏòÅÌñ• Ï°∞ÏÇ¨',
      'ÏûÑÏãú Î¶¨ÏÜåÏä§ Ìï†Îãπ Í≤ÄÌÜ†'
    ];
  }

  // [advice from AI] ÏòàÏ∏° ÎåÄÏùë Ïï°ÏÖò
  getPredictionActions(category, prediction) {
    return [
      'Î¶¨ÏÜåÏä§ ÌôïÏû• Í≥ÑÌöç ÏàòÎ¶Ω',
      'ÏòàÎ∞©Ï†Å ÏµúÏ†ÅÌôî ÏûëÏóÖ Ïã§Ïãú',
      'Î™®ÎãàÌÑ∞ÎßÅ Ï£ºÍ∏∞ Îã®Ï∂ï',
      'ÎπÑÏÉÅ ÎåÄÏùë Ï†àÏ∞® Ï§ÄÎπÑ'
    ];
  }

  // [advice from AI] Î∂ÑÏÑù ÏöîÏïΩ ÏÉùÏÑ±
  generateSummary(analysis) {
    const summary = {
      overallHealth: 'good',
      criticalIssues: 0,
      warnings: 0,
      trends: {},
      topConcerns: []
    };
    
    // Ï†ÑÏ≤¥ Í±¥Í∞ïÎèÑ ÌèâÍ∞Ä
    let totalGradePoints = 0;
    let gradeCount = 0;
    
    for (const [category, categoryAnalysis] of Object.entries(analysis.metrics)) {
      if (categoryAnalysis && categoryAnalysis.grade) {
        const gradePoints = { A: 5, B: 4, C: 3, D: 2, F: 1 };
        totalGradePoints += gradePoints[categoryAnalysis.grade] || 3;
        gradeCount++;
      }
    }
    
    if (gradeCount > 0) {
      const avgGrade = totalGradePoints / gradeCount;
      if (avgGrade >= 4.5) summary.overallHealth = 'excellent';
      else if (avgGrade >= 3.5) summary.overallHealth = 'good';
      else if (avgGrade >= 2.5) summary.overallHealth = 'fair';
      else summary.overallHealth = 'poor';
    }
    
    // Î¨∏Ï†ú Ïàò ÏßëÍ≥Ñ
    summary.criticalIssues = analysis.anomalies.filter(a => a.severity >= 4).length;
    summary.warnings = analysis.anomalies.filter(a => a.severity >= 2 && a.severity < 4).length;
    
    // Ìä∏Î†åÎìú ÏöîÏïΩ
    for (const [category, trend] of Object.entries(analysis.trends)) {
      if (trend && trend.confidence !== 'low') {
        summary.trends[category] = trend.direction;
      }
    }
    
    // Ï£ºÏöî Ïö∞Î†§ÏÇ¨Ìï≠
    const highPriorityRecommendations = analysis.recommendations
      .filter(r => r.priority === 'high')
      .slice(0, 3);
    
    summary.topConcerns = highPriorityRecommendations.map(r => ({
      category: r.category,
      title: r.title,
      type: r.type
    }));
    
    return summary;
  }

  // [advice from AI] ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå
  getSystemStatus() {
    return {
      name: this.name,
      isActive: true,
      configuration: {
        analysisWindow: this.analysisWindow,
        predictionHorizon: this.predictionHorizon,
        trendSensitivity: this.trendSensitivity,
        anomalyThreshold: this.anomalyThreshold
      },
      cache: {
        analyses: this.analysisCache.size,
        trends: this.trendCache.size,
        predictions: this.predictionCache.size
      },
      performanceIndicators: Object.keys(this.performanceIndicators)
    };
  }
}

// [advice from AI] Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
const performanceAnalyzer = new PerformanceAnalyzer({
  name: 'TimbelPerformanceAnalyzer',
  analysisWindow: 24 * 60 * 60 * 1000, // 24ÏãúÍ∞Ñ
  predictionHorizon: 7 * 24 * 60 * 60 * 1000, // 7Ïùº
  trendSensitivity: 0.1,
  anomalyThreshold: 2.5
});

module.exports = {
  PerformanceAnalyzer,
  performanceAnalyzer
};
