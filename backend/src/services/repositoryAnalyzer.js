// [advice from AI] Î†àÌè¨ÏßÄÌÜ†Î¶¨ ÏûêÎèô Î∂ÑÏÑù ÏÑúÎπÑÏä§
const axios = require('axios');
const path = require('path');

class RepositoryAnalyzer {
  constructor() {
    this.githubToken = process.env.GITHUB_TOKEN; // GitHub Personal Access Token
  }

  // [advice from AI] GitHub Î†àÌè¨ÏßÄÌÜ†Î¶¨ Ï†ïÎ≥¥ Î∂ÑÏÑù
  async analyzeRepository(repositoryUrl) {
    try {
      console.log('üîç Î†àÌè¨ÏßÄÌÜ†Î¶¨ Î∂ÑÏÑù ÏãúÏûë:', repositoryUrl);
      
      const repoInfo = this.parseGitHubUrl(repositoryUrl);
      if (!repoInfo) {
        throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ GitHub URLÏûÖÎãàÎã§.');
      }

      // Í∏∞Î≥∏ Î†àÌè¨ÏßÄÌÜ†Î¶¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
      const basicInfo = await this.getBasicRepoInfo(repoInfo.owner, repoInfo.repo);
      
      // ÌååÏùº Íµ¨Ï°∞ Î∂ÑÏÑù
      const fileStructure = await this.analyzeFileStructure(repoInfo.owner, repoInfo.repo);
      
      // README Î∂ÑÏÑù
      const readmeAnalysis = await this.analyzeReadme(repoInfo.owner, repoInfo.repo);
      
      // package.json Î∂ÑÏÑù (Node.js ÌîÑÎ°úÏ†ùÌä∏Ïù∏ Í≤ΩÏö∞)
      const packageInfo = await this.analyzePackageJson(repoInfo.owner, repoInfo.repo);
      
      // Dockerfile Î∂ÑÏÑù
      const dockerInfo = await this.analyzeDockerfile(repoInfo.owner, repoInfo.repo);
      
      // Í∏∞Ïà† Ïä§ÌÉù Ï∂îÎ°†
      const techStack = this.inferTechStack(fileStructure, packageInfo, dockerInfo);
      
      // Î∞∞Ìè¨ ÏÑ§Ï†ï Ï∂îÎ°†
      const deploymentConfig = this.inferDeploymentConfig(fileStructure, packageInfo, dockerInfo, readmeAnalysis);

      const analysis = {
        basic: basicInfo,
        techStack,
        deploymentConfig,
        readme: readmeAnalysis,
        fileStructure,
        packageInfo,
        dockerInfo,
        autoDetected: {
          projectType: this.detectProjectType(fileStructure, packageInfo),
          buildTool: this.detectBuildTool(fileStructure, packageInfo),
          framework: this.detectFramework(fileStructure, packageInfo),
          database: this.detectDatabase(fileStructure, packageInfo, readmeAnalysis),
          ports: this.detectPorts(packageInfo, dockerInfo, readmeAnalysis),
          environment: this.detectEnvironmentVars(packageInfo, dockerInfo, readmeAnalysis)
        }
      };

      console.log('‚úÖ Î†àÌè¨ÏßÄÌÜ†Î¶¨ Î∂ÑÏÑù ÏôÑÎ£å:', analysis);
      return analysis;

    } catch (error) {
      console.error('‚ùå Î†àÌè¨ÏßÄÌÜ†Î¶¨ Î∂ÑÏÑù Ïã§Ìå®:', error);
      throw error;
    }
  }

  // [advice from AI] GitHub URL ÌååÏã±
  parseGitHubUrl(url) {
    const patterns = [
      /github\.com\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/,
      /github\.com\/([^\/]+)\/([^\/]+)/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return {
          owner: match[1],
          repo: match[2].replace('.git', '')
        };
      }
    }
    return null;
  }

  // [advice from AI] Í∏∞Î≥∏ Î†àÌè¨ÏßÄÌÜ†Î¶¨ Ï†ïÎ≥¥
  async getBasicRepoInfo(owner, repo) {
    try {
      const headers = {};
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }

      const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}`, { headers });
      
      return {
        name: response.data.name,
        fullName: response.data.full_name,
        description: response.data.description,
        language: response.data.language,
        topics: response.data.topics || [],
        stars: response.data.stargazers_count,
        forks: response.data.forks_count,
        license: response.data.license?.name,
        defaultBranch: response.data.default_branch,
        createdAt: response.data.created_at,
        updatedAt: response.data.updated_at,
        size: response.data.size,
        isPrivate: response.data.private
      };
    } catch (error) {
      console.warn('Í∏∞Î≥∏ Î†àÌè¨ÏßÄÌÜ†Î¶¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error.message);
      return null;
    }
  }

  // [advice from AI] ÌååÏùº Íµ¨Ï°∞ Î∂ÑÏÑù
  async analyzeFileStructure(owner, repo) {
    try {
      const headers = {};
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }

      const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}/contents`, { headers });
      
      const files = response.data.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        size: item.size
      }));

      return {
        rootFiles: files,
        hasDockerfile: files.some(f => f.name === 'Dockerfile'),
        hasPackageJson: files.some(f => f.name === 'package.json'),
        hasRequirementsTxt: files.some(f => f.name === 'requirements.txt'),
        hasPomXml: files.some(f => f.name === 'pom.xml'),
        hasGradleBuild: files.some(f => f.name.includes('build.gradle')),
        hasDockerCompose: files.some(f => f.name.includes('docker-compose')),
        hasKubernetesFiles: files.some(f => f.name.includes('k8s') || f.name.includes('kubernetes')),
        hasJenkinsfile: files.some(f => f.name === 'Jenkinsfile'),
        hasGithubActions: files.some(f => f.name === '.github')
      };
    } catch (error) {
      console.warn('ÌååÏùº Íµ¨Ï°∞ Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      return {};
    }
  }

  // [advice from AI] README Î∂ÑÏÑù
  async analyzeReadme(owner, repo) {
    try {
      const headers = {};
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }

      const readmeFiles = ['README.md', 'README.rst', 'README.txt', 'readme.md'];
      
      for (const filename of readmeFiles) {
        try {
          const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}/contents/${filename}`, { headers });
          const content = Buffer.from(response.data.content, 'base64').toString('utf-8');
          
          return {
            filename,
            content,
            analysis: {
              ports: this.extractPorts(content),
              environment: this.extractEnvironmentVars(content),
              dependencies: this.extractDependencies(content),
              installation: this.extractInstallationSteps(content),
              usage: this.extractUsageInfo(content),
              deployment: this.extractDeploymentInfo(content)
            }
          };
        } catch (err) {
          continue;
        }
      }
      
      return null;
    } catch (error) {
      console.warn('README Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      return null;
    }
  }

  // [advice from AI] package.json Î∂ÑÏÑù
  async analyzePackageJson(owner, repo) {
    try {
      const headers = {};
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }

      const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}/contents/package.json`, { headers });
      const content = Buffer.from(response.data.content, 'base64').toString('utf-8');
      const packageJson = JSON.parse(content);
      
      return {
        name: packageJson.name,
        version: packageJson.version,
        description: packageJson.description,
        main: packageJson.main,
        scripts: packageJson.scripts || {},
        dependencies: packageJson.dependencies || {},
        devDependencies: packageJson.devDependencies || {},
        engines: packageJson.engines || {},
        author: packageJson.author,
        license: packageJson.license,
        repository: packageJson.repository,
        keywords: packageJson.keywords || []
      };
    } catch (error) {
      console.warn('package.json Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      return null;
    }
  }

  // [advice from AI] Dockerfile Î∂ÑÏÑù
  async analyzeDockerfile(owner, repo) {
    try {
      const headers = {};
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }

      const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}/contents/Dockerfile`, { headers });
      const content = Buffer.from(response.data.content, 'base64').toString('utf-8');
      
      return {
        content,
        baseImage: this.extractBaseImage(content),
        exposedPorts: this.extractExposedPorts(content),
        workdir: this.extractWorkdir(content),
        entrypoint: this.extractEntrypoint(content),
        cmd: this.extractCmd(content),
        env: this.extractDockerEnv(content)
      };
    } catch (error) {
      console.warn('Dockerfile Î∂ÑÏÑù Ïã§Ìå®:', error.message);
      return null;
    }
  }

  // [advice from AI] Í∏∞Ïà† Ïä§ÌÉù Ï∂îÎ°†
  inferTechStack(fileStructure, packageInfo, dockerInfo) {
    const stack = {
      language: [],
      framework: [],
      database: [],
      tools: [],
      deployment: []
    };

    // Ïñ∏Ïñ¥ Í∞êÏßÄ
    if (fileStructure.hasPackageJson || packageInfo) {
      stack.language.push('JavaScript/Node.js');
    }
    if (fileStructure.hasRequirementsTxt) {
      stack.language.push('Python');
    }
    if (fileStructure.hasPomXml) {
      stack.language.push('Java');
    }
    if (fileStructure.hasGradleBuild) {
      stack.language.push('Java/Kotlin');
    }

    // ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í∞êÏßÄ
    if (packageInfo?.dependencies) {
      const deps = Object.keys(packageInfo.dependencies);
      if (deps.includes('react')) stack.framework.push('React');
      if (deps.includes('vue')) stack.framework.push('Vue.js');
      if (deps.includes('angular')) stack.framework.push('Angular');
      if (deps.includes('express')) stack.framework.push('Express.js');
      if (deps.includes('fastify')) stack.framework.push('Fastify');
      if (deps.includes('koa')) stack.framework.push('Koa.js');
      if (deps.includes('next')) stack.framework.push('Next.js');
      if (deps.includes('nuxt')) stack.framework.push('Nuxt.js');
    }

    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞êÏßÄ
    if (packageInfo?.dependencies) {
      const deps = Object.keys(packageInfo.dependencies);
      if (deps.includes('pg') || deps.includes('postgres')) stack.database.push('PostgreSQL');
      if (deps.includes('mysql') || deps.includes('mysql2')) stack.database.push('MySQL');
      if (deps.includes('mongodb') || deps.includes('mongoose')) stack.database.push('MongoDB');
      if (deps.includes('redis')) stack.database.push('Redis');
      if (deps.includes('sqlite3')) stack.database.push('SQLite');
    }

    // Î∞∞Ìè¨ ÎèÑÍµ¨ Í∞êÏßÄ
    if (fileStructure.hasDockerfile) stack.deployment.push('Docker');
    if (fileStructure.hasDockerCompose) stack.deployment.push('Docker Compose');
    if (fileStructure.hasKubernetesFiles) stack.deployment.push('Kubernetes');
    if (fileStructure.hasJenkinsfile) stack.deployment.push('Jenkins');
    if (fileStructure.hasGithubActions) stack.deployment.push('GitHub Actions');

    return stack;
  }

  // [advice from AI] Î∞∞Ìè¨ ÏÑ§Ï†ï Ï∂îÎ°†
  inferDeploymentConfig(fileStructure, packageInfo, dockerInfo, readmeAnalysis) {
    const config = {
      buildCommand: 'npm run build',
      startCommand: 'npm start',
      port: 3000,
      environment: 'production',
      healthCheckPath: '/health',
      resourceRequirements: {
        cpu: '500m',
        memory: '512Mi'
      }
    };

    // package.json Ïä§ÌÅ¨Î¶ΩÌä∏ Í∏∞Î∞ò Î™ÖÎ†πÏñ¥ Ï∂îÎ°†
    if (packageInfo?.scripts) {
      if (packageInfo.scripts.build) {
        config.buildCommand = 'npm run build';
      }
      if (packageInfo.scripts.start) {
        config.startCommand = 'npm start';
      }
      if (packageInfo.scripts.dev) {
        config.devCommand = 'npm run dev';
      }
    }

    // Ìè¨Ìä∏ Ï∂îÎ°†
    if (dockerInfo?.exposedPorts?.length > 0) {
      config.port = parseInt(dockerInfo.exposedPorts[0]);
    } else if (readmeAnalysis?.analysis?.ports?.length > 0) {
      config.port = parseInt(readmeAnalysis.analysis.ports[0]);
    }

    // ÌôòÍ≤Ω Î≥ÄÏàò Ï∂îÎ°†
    if (readmeAnalysis?.analysis?.environment) {
      config.environmentVariables = readmeAnalysis.analysis.environment;
    }

    return config;
  }

  // [advice from AI] ÌîÑÎ°úÏ†ùÌä∏ ÌÉÄÏûÖ Í∞êÏßÄ
  detectProjectType(fileStructure, packageInfo) {
    if (packageInfo?.dependencies) {
      const deps = Object.keys(packageInfo.dependencies);
      if (deps.includes('react') || deps.includes('vue') || deps.includes('angular')) {
        return 'frontend';
      }
      if (deps.includes('express') || deps.includes('fastify') || deps.includes('koa')) {
        return 'backend';
      }
    }
    
    if (fileStructure.hasPackageJson) return 'nodejs';
    if (fileStructure.hasRequirementsTxt) return 'python';
    if (fileStructure.hasPomXml) return 'java';
    
    return 'unknown';
  }

  // [advice from AI] ÎπåÎìú ÎèÑÍµ¨ Í∞êÏßÄ
  detectBuildTool(fileStructure, packageInfo) {
    if (packageInfo?.scripts?.build) return 'npm';
    if (fileStructure.hasGradleBuild) return 'gradle';
    if (fileStructure.hasPomXml) return 'maven';
    return 'unknown';
  }

  // [advice from AI] ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í∞êÏßÄ
  detectFramework(fileStructure, packageInfo) {
    if (packageInfo?.dependencies) {
      const deps = Object.keys(packageInfo.dependencies);
      if (deps.includes('react')) return 'React';
      if (deps.includes('vue')) return 'Vue.js';
      if (deps.includes('angular')) return 'Angular';
      if (deps.includes('express')) return 'Express.js';
      if (deps.includes('next')) return 'Next.js';
    }
    return 'unknown';
  }

  // [advice from AI] Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞êÏßÄ
  detectDatabase(fileStructure, packageInfo, readmeAnalysis) {
    const databases = [];
    
    if (packageInfo?.dependencies) {
      const deps = Object.keys(packageInfo.dependencies);
      if (deps.includes('pg')) databases.push('PostgreSQL');
      if (deps.includes('mysql2')) databases.push('MySQL');
      if (deps.includes('mongoose')) databases.push('MongoDB');
      if (deps.includes('redis')) databases.push('Redis');
    }
    
    if (readmeAnalysis?.content) {
      const content = readmeAnalysis.content.toLowerCase();
      if (content.includes('postgresql') || content.includes('postgres')) databases.push('PostgreSQL');
      if (content.includes('mysql')) databases.push('MySQL');
      if (content.includes('mongodb') || content.includes('mongo')) databases.push('MongoDB');
      if (content.includes('redis')) databases.push('Redis');
    }
    
    return [...new Set(databases)];
  }

  // [advice from AI] Ìè¨Ìä∏ Í∞êÏßÄ
  detectPorts(packageInfo, dockerInfo, readmeAnalysis) {
    const ports = [];
    
    if (dockerInfo?.exposedPorts) {
      ports.push(...dockerInfo.exposedPorts.map(p => parseInt(p)));
    }
    
    if (readmeAnalysis?.analysis?.ports) {
      ports.push(...readmeAnalysis.analysis.ports.map(p => parseInt(p)));
    }
    
    // Í∏∞Î≥∏ Ìè¨Ìä∏ Ï∂îÎ°†
    if (ports.length === 0) {
      if (packageInfo?.dependencies?.express) ports.push(3000);
      if (packageInfo?.dependencies?.react) ports.push(3000);
      if (packageInfo?.dependencies?.vue) ports.push(8080);
    }
    
    return [...new Set(ports)];
  }

  // [advice from AI] ÌôòÍ≤Ω Î≥ÄÏàò Í∞êÏßÄ
  detectEnvironmentVars(packageInfo, dockerInfo, readmeAnalysis) {
    const envVars = [];
    
    if (readmeAnalysis?.analysis?.environment) {
      envVars.push(...readmeAnalysis.analysis.environment);
    }
    
    if (dockerInfo?.env) {
      envVars.push(...dockerInfo.env);
    }
    
    return [...new Set(envVars)];
  }

  // [advice from AI] ÌÖçÏä§Ìä∏ÏóêÏÑú Ìè¨Ìä∏ Ï∂îÏ∂ú
  extractPorts(text) {
    const portRegex = /(?:port|PORT|Port)[\s:=]+(\d{4,5})/g;
    const matches = [];
    let match;
    
    while ((match = portRegex.exec(text)) !== null) {
      matches.push(match[1]);
    }
    
    return matches;
  }

  // [advice from AI] ÌôòÍ≤Ω Î≥ÄÏàò Ï∂îÏ∂ú
  extractEnvironmentVars(text) {
    const envRegex = /([A-Z_][A-Z0-9_]*)\s*=\s*['"']?([^'"'\n\r]+)['"']?/g;
    const matches = [];
    let match;
    
    while ((match = envRegex.exec(text)) !== null) {
      matches.push({
        name: match[1],
        example: match[2]
      });
    }
    
    return matches;
  }

  // [advice from AI] ÏùòÏ°¥ÏÑ± Ï∂îÏ∂ú
  extractDependencies(text) {
    const deps = [];
    
    // npm install Î™ÖÎ†πÏñ¥ÏóêÏÑú Ï∂îÏ∂ú
    const npmRegex = /npm install\s+([\w\-@\/\s]+)/g;
    let match;
    while ((match = npmRegex.exec(text)) !== null) {
      deps.push(...match[1].split(/\s+/).filter(dep => dep.trim()));
    }
    
    return deps;
  }

  // [advice from AI] ÏÑ§Ïπò Îã®Í≥Ñ Ï∂îÏ∂ú
  extractInstallationSteps(text) {
    const steps = [];
    const lines = text.split('\n');
    
    let inInstallSection = false;
    for (const line of lines) {
      if (line.toLowerCase().includes('install') || line.toLowerCase().includes('setup')) {
        inInstallSection = true;
      }
      
      if (inInstallSection && (line.startsWith('1.') || line.startsWith('-') || line.startsWith('*'))) {
        steps.push(line.trim());
      }
      
      if (line.startsWith('#') && steps.length > 0) {
        break;
      }
    }
    
    return steps;
  }

  // [advice from AI] ÏÇ¨Ïö©Î≤ï Ï†ïÎ≥¥ Ï∂îÏ∂ú
  extractUsageInfo(text) {
    const usageRegex = /(?:usage|Usage|USAGE|how to use|How to Use)([\s\S]*?)(?:\n#{1,3}|\n\n|$)/i;
    const match = text.match(usageRegex);
    return match ? match[1].trim() : null;
  }

  // [advice from AI] Î∞∞Ìè¨ Ï†ïÎ≥¥ Ï∂îÏ∂ú
  extractDeploymentInfo(text) {
    const deployRegex = /(?:deploy|Deploy|DEPLOY|deployment|Deployment)([\s\S]*?)(?:\n#{1,3}|\n\n|$)/i;
    const match = text.match(deployRegex);
    return match ? match[1].trim() : null;
  }

  // [advice from AI] DockerfileÏóêÏÑú Î≤†Ïù¥Ïä§ Ïù¥ÎØ∏ÏßÄ Ï∂îÏ∂ú
  extractBaseImage(dockerfileContent) {
    const match = dockerfileContent.match(/FROM\s+([^\s\n]+)/i);
    return match ? match[1] : null;
  }

  // [advice from AI] DockerfileÏóêÏÑú ÎÖ∏Ï∂ú Ìè¨Ìä∏ Ï∂îÏ∂ú
  extractExposedPorts(dockerfileContent) {
    const matches = dockerfileContent.match(/EXPOSE\s+(\d+)/gi);
    return matches ? matches.map(m => m.match(/\d+/)[0]) : [];
  }

  // [advice from AI] DockerfileÏóêÏÑú ÏûëÏóÖ ÎîîÎ†âÌÜ†Î¶¨ Ï∂îÏ∂ú
  extractWorkdir(dockerfileContent) {
    const match = dockerfileContent.match(/WORKDIR\s+([^\s\n]+)/i);
    return match ? match[1] : null;
  }

  // [advice from AI] DockerfileÏóêÏÑú ÏóîÌä∏Î¶¨Ìè¨Ïù∏Ìä∏ Ï∂îÏ∂ú
  extractEntrypoint(dockerfileContent) {
    const match = dockerfileContent.match(/ENTRYPOINT\s+\[(.*?)\]/i);
    return match ? JSON.parse(`[${match[1]}]`) : null;
  }

  // [advice from AI] DockerfileÏóêÏÑú CMD Ï∂îÏ∂ú
  extractCmd(dockerfileContent) {
    const match = dockerfileContent.match(/CMD\s+\[(.*?)\]/i);
    return match ? JSON.parse(`[${match[1]}]`) : null;
  }

  // [advice from AI] DockerfileÏóêÏÑú ÌôòÍ≤Ω Î≥ÄÏàò Ï∂îÏ∂ú
  extractDockerEnv(dockerfileContent) {
    const matches = dockerfileContent.match(/ENV\s+([A-Z_][A-Z0-9_]*)\s*=?\s*([^\n\r]+)/gi);
    return matches ? matches.map(m => {
      const parts = m.replace(/^ENV\s+/i, '').split(/\s*=\s*/);
      return {
        name: parts[0],
        value: parts[1] || ''
      };
    }) : [];
  }
}

module.exports = RepositoryAnalyzer;
